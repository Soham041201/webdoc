/**
 * OpenAPI documentation exporter
 */

import type { Flow } from "../agent/FlowTracker.js";
import type { CapturedCall } from "../browser/networkRecorder.js";

export interface OpenAPISpec {
  openapi: string;
  info: {
    title: string;
    version: string;
    description: string;
  };
  servers?: Array<{ url: string; description?: string }>;
  paths: Record<string, any>;
}

export function exportToOpenAPI(flows: Flow[]): OpenAPISpec {
  const paths: Record<string, any> = {};

  // Extract unique API endpoints from flows
  for (const flow of flows) {
    for (const step of flow.steps) {
      for (const call of step.networkCalls) {
        const url = call.url;
        const method = call.method.toLowerCase();

        // Extract path from URL (simplified)
        const urlObj = new URL(url);
        const path = urlObj.pathname;

        if (!paths[path]) {
          paths[path] = {};
        }

        if (!paths[path][method]) {
          paths[path][method] = {
            summary: `${method.toUpperCase()} ${path}`,
            description: `Triggered by: ${step.step}`,
            responses: {
              [call.status]: {
                description: `Status ${call.status}`,
              },
            },
          };
        }
      }
    }
  }

  return {
    openapi: "3.0.0",
    info: {
      title: "WebDoc Agent API Documentation",
      version: "1.0.0",
      description: "Generated by WebDoc Agent",
    },
    paths,
  };
}

export interface DocMetadata {
  capturedAt: string;
  sourceUrl: string;
  totalCalls: number;
  uniqueEndpoints: number;
  pagesExplored?: string[];
  sessionDuration?: string;
}

export function exportCallsToOpenAPI(
  calls: CapturedCall[],
  baseUrl: string,
  metadata?: DocMetadata,
): OpenAPISpec {
  const paths: Record<string, any> = {};
  const headerAllowlist = [
    "content-type",
    "authorization",
    "x-api-key",
    "x-request-id",
    "x-csrf-token",
    "x-xsrf-token",
  ];

  for (const call of calls) {
    let path = call.url;
    try {
      const urlObj = new URL(call.url);
      path = urlObj.pathname;
    } catch {
      // use raw URL as fallback
    }

    const method = call.method.toLowerCase();
    if (!paths[path]) {
      paths[path] = {};
    }

    if (!paths[path][method]) {
      paths[path][method] = {
        summary: `${method.toUpperCase()} ${path}`,
        responses: {},
      };
    }

    const operation = paths[path][method];

    const requestHeaderKeys = Object.keys(call.requestHeaders || {})
      .map((key) => key.toLowerCase())
      .filter((key) => headerAllowlist.includes(key));
    if (requestHeaderKeys.length > 0) {
      const existing = Array.isArray(operation.parameters)
        ? operation.parameters
        : [];
      const seen = new Set(
        existing.map((param: any) => `${param.in}:${param.name}`),
      );
      for (const header of requestHeaderKeys) {
        const key = `header:${header}`;
        if (seen.has(key)) continue;
        existing.push({
          name: header,
          in: "header",
          required: false,
          schema: { type: "string" },
          description: "Observed header",
        });
        seen.add(key);
      }
      operation.parameters = existing;
    }

    const requestBody = parseJsonBody(call.requestBody);
    if (requestBody) {
      operation.requestBody = {
        content: {
          "application/json": {
            example: requestBody,
          },
        },
      };
    }

    const responseBody = parseJsonBody(call.responseBody);
    if (!operation.responses[call.status]) {
      operation.responses[call.status] = {
        description: `Status ${call.status}`,
      };
    }
    if (responseBody) {
      operation.responses[call.status].content = {
        "application/json": {
          example: responseBody,
        },
      };
    }
  }

  const uniqueEndpoints = Object.keys(paths).length;
  let hostname = "API";
  try {
    hostname = new URL(baseUrl).hostname;
  } catch {
    // ignore
  }

  const descriptionLines = [
    `Auto-generated by WebDoc Agent from observed browser traffic on ${hostname}.`,
  ];
  if (metadata) {
    descriptionLines.push(`Captured: ${metadata.capturedAt}`);
    descriptionLines.push(
      `Source: ${metadata.sourceUrl} | ${metadata.totalCalls} total calls | ${metadata.uniqueEndpoints} unique endpoints`,
    );
    if (metadata.pagesExplored && metadata.pagesExplored.length > 0) {
      descriptionLines.push(
        `Pages explored: ${metadata.pagesExplored.join(", ")}`,
      );
    }
    if (metadata.sessionDuration) {
      descriptionLines.push(`Session duration: ${metadata.sessionDuration}`);
    }
  }

  return {
    openapi: "3.0.0",
    info: {
      title: `${hostname} API Documentation`,
      version: "1.0.0",
      description: descriptionLines.join("\n"),
    },
    servers: [{ url: baseUrl }],
    paths,
  };
}

function parseJsonBody(body?: string): any | null {
  if (!body) return null;
  const trimmed = body.trim();
  if (!trimmed) return null;
  try {
    return JSON.parse(trimmed);
  } catch {
    return null;
  }
}
